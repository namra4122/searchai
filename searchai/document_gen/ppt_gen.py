"""
PowerPoint document generation module for the SearchAI application.
"""

import os
import re
import logging
import asyncio
from datetime import datetime
from pathlib import Path

from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.enum.text import PP_ALIGN, MSO_VERTICAL_ANCHOR
from pptx.dml.color import RGBColor
from pptx.enum.shapes import MSO_SHAPE

from searchai.config import OUTPUT_DIR

# Configure logging
from searchai.utils.logging_config import get_logger

logger = get_logger(__name__)

# Define color schemes
COLOR_SCHEMES = {
    'tech': {
        'primary': RGBColor(0, 114, 198),  # Deep Blue
        'secondary': RGBColor(0, 182, 240),  # Light Blue
        'accent': RGBColor(255, 140, 0),    # Orange
        'background': RGBColor(240, 244, 248)  # Light Gray-Blue
    },
    'business': {
        'primary': RGBColor(31, 73, 125),   # Navy
        'secondary': RGBColor(68, 114, 196), # Blue
        'accent': RGBColor(198, 89, 17),     # Brown
        'background': RGBColor(244, 244, 244)  # Light Gray
    },
    'science': {
        'primary': RGBColor(0, 121, 107),   # Teal
        'secondary': RGBColor(0, 150, 136),  # Light Teal
        'accent': RGBColor(255, 87, 34),     # Orange-Red
        'background': RGBColor(242, 246, 245)  # Light Teal-Gray
    },
    'education': {
        'primary': RGBColor(103, 58, 183),  # Purple
        'secondary': RGBColor(156, 39, 176), # Light Purple
        'accent': RGBColor(255, 193, 7),     # Amber
        'background': RGBColor(245, 243, 248)  # Light Purple-Gray
    }
}

def apply_theme_colors(slide, theme):
    """Apply theme colors to a slide"""
    colors = COLOR_SCHEMES.get(theme, COLOR_SCHEMES['tech'])
    
    # Apply background
    slide.background.fill.solid()
    slide.background.fill.fore_color.rgb = colors['background']
    
    # Apply colors to shapes
    for shape in slide.shapes:
        if shape.has_text_frame:
            for paragraph in shape.text_frame.paragraphs:
                paragraph.font.color.rgb = colors['primary']

def add_slide_transition(slide):
    """Add transition effect to slide"""
    # Note: python-pptx doesn't support transitions directly
    # This is a placeholder for future implementation
    pass

def create_title_slide(prs, title, subtitle, theme='tech'):
    """Create an attractive title slide"""
    slide = prs.slides.add_slide(prs.slide_layouts[0])
    apply_theme_colors(slide, theme)
    
    # Add a background shape
    left = top = 0
    width = height = Inches(10)
    shape = slide.shapes.add_shape(MSO_SHAPE.RECTANGLE, left, top, width, height)
    shape.fill.solid()
    shape.fill.fore_color.rgb = COLOR_SCHEMES[theme]['background']
    shape.line.fill.background()
    
    # Add title
    title_box = slide.shapes.title
    title_box.text = title
    title_box.text_frame.paragraphs[0].font.size = Pt(44)
    title_box.text_frame.paragraphs[0].font.color.rgb = COLOR_SCHEMES[theme]['primary']
    
    # Add subtitle
    subtitle_box = slide.placeholders[1]
    subtitle_box.text = subtitle
    subtitle_box.text_frame.paragraphs[0].font.size = Pt(28)
    subtitle_box.text_frame.paragraphs[0].font.color.rgb = COLOR_SCHEMES[theme]['secondary']

def create_content_slide(prs, title, bullets, layout='content', theme='tech'):
    """Create a content slide with enhanced styling"""
    slide = prs.slides.add_slide(prs.slide_layouts[1])
    apply_theme_colors(slide, theme)
    
    # Add title
    title_shape = slide.shapes.title
    title_shape.text = title
    title_shape.text_frame.paragraphs[0].font.size = Pt(36)
    title_shape.text_frame.paragraphs[0].font.color.rgb = COLOR_SCHEMES[theme]['primary']
    
    # Add content
    content = slide.placeholders[1]
    text_frame = content.text_frame
    text_frame.clear()
    
    for bullet in bullets:
        p = text_frame.add_paragraph()
        p.text = bullet
        p.font.size = Pt(24)
        p.font.color.rgb = COLOR_SCHEMES[theme]['secondary']
        p.level = 0

def add_footer(slide, text):
    """Add footer to slide"""
    left = Inches(0.5)
    top = Inches(7)
    width = Inches(9)
    height = Inches(0.5)
    
    txBox = slide.shapes.add_textbox(left, top, width, height)
    tf = txBox.text_frame
    tf.text = text
    tf.paragraphs[0].alignment = PP_ALIGN.CENTER
    tf.paragraphs[0].font.size = Pt(10)
    tf.paragraphs[0].font.color.rgb = RGBColor(128, 128, 128)

async def generate_ppt(content: str, query: str, query_id: str) -> tuple:
    """
    Generate a PowerPoint presentation from the LLM content.
    
    Args:
        content (str): The content generated by the LLM
        query (str): The original user query
        query_id (str): The database ID of the query
        
    Returns:
        tuple: (file_path, file_size) - Path to the generated file and its size
    """
    logger.info("Generating PowerPoint presentation")
    
    # Create a filename based on the query
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    safe_query = "".join(c if c.isalnum() else "_" for c in query[:30])
    filename = f"{safe_query}_{timestamp}.pptx"
    
    # Create the output directory for this query
    query_dir = os.path.join(OUTPUT_DIR, query_id)
    os.makedirs(query_dir, exist_ok=True)
    
    # Full path to the output file
    output_path = os.path.join(query_dir, filename)
    
    try:
        # Check if the content is already formatted for slides
        if "--- Slide:" in content:
            # Use the pre-formatted content
            return await _generate_ppt_from_structured_content(content, query, output_path)
        else:
            # Parse the content to extract slide information
            return await _generate_ppt_from_unstructured_content(content, query, output_path)
    except Exception as e:
        logger.error(f"Error generating PowerPoint presentation: {e}")
        raise

async def _generate_ppt_from_structured_content(content: str, query: str, output_path: str) -> tuple:
    """Generate a PowerPoint from structured content"""
    loop = asyncio.get_event_loop()
    
    def create_ppt():
        prs = Presentation()
        theme = 'tech'  # Default theme
        
        # Parse content for theme
        if 'Theme:' in content:
            theme_match = re.search(r'Theme:\s*(\w+)', content)
            if theme_match and theme_match.group(1).lower() in COLOR_SCHEMES:
                theme = theme_match.group(1).lower()
        
        # Process slides
        slides = content.split('--- Slide:')
        for slide_content in slides[1:]:  # Skip empty first split
            # Extract slide components
            title = slide_content.split('\n')[0].strip()
            
            # Extract bullet points
            bullets = [line.strip()[2:] for line in slide_content.split('\n') 
                      if line.strip().startswith('•')]
            
            # Create appropriate slide type
            if 'Title' in title:
                subtitle = next((line for line in slide_content.split('\n') 
                               if 'Subtitle:' in line), '')
                subtitle = subtitle.replace('Subtitle:', '').strip()
                create_title_slide(prs, query, subtitle, theme)
            else:
                create_content_slide(prs, title, bullets, theme=theme)
            
            # Add footer to each slide
            add_footer(prs.slides[-1], f"Generated by SearchAI • {datetime.now().strftime('%Y-%m-%d')}")
        
        # Save the presentation
        prs.save(output_path)
    
    # Run the PPT creation in a separate thread
    await loop.run_in_executor(None, create_ppt)
    
    # Get file size
    file_size = os.path.getsize(output_path)
    logger.info(f"PowerPoint presentation generated: {output_path}")
    
    return output_path, file_size

async def _generate_ppt_from_unstructured_content(content: str, query: str, output_path: str) -> tuple:
    """
    Generate a PowerPoint from unstructured content by parsing headings and sections.
    
    Args:
        content (str): The unstructured content generated by the LLM
        query (str): The original user query
        output_path (str): Path where the PPT should be saved
        
    Returns:
        tuple: (file_path, file_size) - Path to the generated file and its size
    """
    loop = asyncio.get_event_loop()
    
    def create_ppt():
        # Create a new presentation
        prs = Presentation()
        
        # Add a title slide
        title_slide_layout = prs.slide_layouts[0]  # Title layout
        slide = prs.slides.add_slide(title_slide_layout)
        title = slide.shapes.title
        subtitle = slide.placeholders[1]
        
        title.text = query
        timestamp = datetime.now().strftime('%Y-%m-%d')
        subtitle.text = f"Generated by SearchAI | {timestamp}"
        
        # Content slide layout
        content_slide_layout = prs.slide_layouts[1]  # Content layout
        section_slide_layout = prs.slide_layouts[2]  # Section layout
        
        # Split the content by headers (# or ## markdown headers)
        # First, find all headers and their positions
        header_positions = []
        lines = content.split('\n')
        
        for i, line in enumerate(lines):
            if line.strip().startswith('# ') or line.strip().startswith('## '):
                header_level = 1 if line.strip().startswith('# ') else 2
                header_text = line.strip('#').strip()
                header_positions.append((i, header_level, header_text))
        
        # If no headers were found, create a simple content slide
        if not header_positions:
            slide = prs.slides.add_slide(content_slide_layout)
            slide.shapes.title.text = "Content"
            
            content_placeholder = slide.placeholders[1]
            tf = content_placeholder.text_frame
            
            # Add condensed content
            summarized_content = '\n'.join(lines[:min(15, len(lines))])
            tf.text = summarized_content
            
            if len(lines) > 15:
                tf.text += "\n[Content truncated...]"
        else:
            # Process each section between headers
            for i in range(len(header_positions)):
                current_pos, level, header_text = header_positions[i]
                
                # Determine the end position for this section
                if i < len(header_positions) - 1:
                    end_pos = header_positions[i+1][0]
                else:
                    end_pos = len(lines)
                
                # Section content (excluding the header line)
                section_content = '\n'.join(lines[current_pos+1:end_pos]).strip()
                
                # Create a slide for this section
                if level == 1:
                    # Use section layout for main headers
                    slide = prs.slides.add_slide(section_slide_layout)
                    title = slide.shapes.title
                    title.text = header_text
                    
                    # Try to get subtitle if available
                    subtitle_placeholder = None
                    for shape in slide.placeholders:
                        if shape.placeholder_format.type == 2:  # Subtitle
                            subtitle_placeholder = shape
                            break
                    
                    if subtitle_placeholder and section_content:
                        # Extract first paragraph for subtitle
                        first_para = section_content.split('\n', 1)[0]
                        subtitle_placeholder.text = first_para
                else:
                    # Use content layout for subheaders
                    slide = prs.slides.add_slide(content_slide_layout)
                    title = slide.shapes.title
                    title.text = header_text
                    
                    content_placeholder = slide.placeholders[1]
                    tf = content_placeholder.text_frame
                    
                    # Extract bullet points if present
                    bullet_points = [line.strip() for line in section_content.split('\n') 
                                    if line.strip().startswith(('*', '-', '•'))]
                    
                    # If bullet points are present, use them
                    if bullet_points:
                        for i, point in enumerate(bullet_points):
                            if i == 0:
                                p = tf.paragraphs[0]
                            else:
                                p = tf.add_paragraph()
                            
                            # Remove the bullet character and whitespace
                            clean_point = re.sub(r'^[*\-•]\s*', '', point)
                            p.text = clean_point
                            p.level = 0
                    else:
                        # Otherwise use regular paragraphs
                        paragraphs = [p for p in section_content.split('\n\n') if p.strip()]
                        
                        if paragraphs:
                            # Use the first few paragraphs
                            for i, para in enumerate(paragraphs[:3]):  # Limit to 3 paragraphs
                                if i == 0:
                                    tf.text = para
                                else:
                                    p = tf.add_paragraph()
                                    p.text = para
                                
                            if len(paragraphs) > 3:
                                p = tf.add_paragraph()
                                p.text = "[Additional content omitted...]"
        
        # Add a concluding slide
        slide = prs.slides.add_slide(content_slide_layout)
        slide.shapes.title.text = "Thank You"
        
        content_placeholder = slide.placeholders[1]
        tf = content_placeholder.text_frame
        tf.text = f"This presentation was generated based on the query:\n\"{query}\""
        
        p = tf.add_paragraph()
        p.text = f"Generated by SearchAI on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        
        # Save the presentation
        prs.save(output_path)
    
    # Run the PPT creation in a separate thread
    await loop.run_in_executor(None, create_ppt)
    
    # Get file size
    file_size = os.path.getsize(output_path)
    logger.info(f"PowerPoint presentation generated from unstructured content: {output_path}")
    
    return output_path, file_size