"""
PDF document generation module for the SearchAI application.
"""

import os
import logging
import asyncio
import tempfile
from datetime import datetime
from pathlib import Path
from typing import Tuple

from reportlab.lib.pagesizes import letter
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
import markdown
import pdfkit

from searchai.config import OUTPUT_DIR
from searchai.utils.logging_config import get_logger
from searchai.utils.exceptions import DocumentGenerationError, FileSystemError, FormatError, ValidationError


# Configure logging
logger = get_logger(__name__)

async def generate_pdf(content: str, query: str, query_id: str) -> Tuple[str, int]:
    """
    Generate a PDF document from the LLM content.
    
    Args:
        content (str): The content generated by the LLM
        query (str): The original user query
        query_id (str): The database ID of the query
        
    Returns:
        tuple: (file_path, file_size) - Path to the generated file and its size
        
    Raises:
        DocumentGenerationError: If document generation fails
        FileSystemError: If file operations fail
        FormatError: If content formatting fails
    """
    logger.info("Generating PDF document")
    
    try:
        # Validate inputs
        if not content or not content.strip():
            raise FormatError("Content is empty")
        if not query or not query.strip():
            raise ValidationError("Query is empty")
            
        # Create filename and paths
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_query = "".join(c if c.isalnum() else "_" for c in query[:30])
            filename = f"{safe_query}_{timestamp}.pdf"
            query_dir = os.path.join(OUTPUT_DIR, query_id)
            os.makedirs(query_dir, exist_ok=True)
            output_path = os.path.join(query_dir, filename)
        except Exception as e:
            raise FileSystemError(f"Failed to prepare output path: {str(e)}")
        
        try:
            # Try first approach: Convert Markdown to HTML to PDF
            try:
                return await _generate_pdf_via_markdown(content, query, output_path)
            except Exception as e:
                logger.warning(f"Failed to generate PDF via markdown/pdfkit: {e}")
                logger.info("Falling back to ReportLab for PDF generation")
                # Fall back to second approach
                return await _generate_pdf_via_reportlab(content, query, output_path)
                
        except Exception as e:
            raise DocumentGenerationError(
                message="All PDF generation methods failed",
                format="pdf",
                details=str(e)
            )
            
    except (DocumentGenerationError, FileSystemError, FormatError):
        raise
    except Exception as e:
        raise DocumentGenerationError(
            message=f"Unexpected error during PDF generation: {str(e)}",
            format="pdf"
        )

async def _generate_pdf_via_markdown(content: str, query: str, output_path: str) -> tuple:
    """
    Generate a PDF by converting markdown to HTML and then to PDF.
    
    Args:
        content (str): The content generated by the LLM
        query (str): The original user query
        output_path (str): Path where the PDF should be saved
        
    Returns:
        tuple: (file_path, file_size) - Path to the generated file and its size
    """
    # Prepare the complete markdown content with title
    md_content = f"# {query}\n\n"
    md_content += f"*Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n\n"
    md_content += f"---\n\n"
    md_content += content
    
    # Convert markdown to HTML
    html = markdown.markdown(md_content, extensions=['tables', 'fenced_code'])
    
    # Add some basic styling to the HTML
    styled_html = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>{query}</title>
        <style>
            body {{ font-family: Arial, sans-serif; line-height: 1.6; margin: 40px; }}
            h1 {{ color: #2c3e50; border-bottom: 1px solid #eee; padding-bottom: 10px; }}
            h2 {{ color: #3498db; margin-top: 30px; }}
            h3 {{ color: #2980b9; }}
            code {{ background: #f8f8f8; padding: 2px 5px; border-radius: 3px; }}
            pre {{ background: #f8f8f8; padding: 15px; border-radius: 5px; overflow-x: auto; }}
            blockquote {{ border-left: 4px solid #ccc; padding-left: 15px; color: #555; }}
            table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
            th, td {{ border: 1px solid #ddd; padding: 8px 12px; text-align: left; }}
            th {{ background-color: #f2f2f2; }}
            img {{ max-width: 100%; height: auto; }}
        </style>
    </head>
    <body>
        {html}
        <div style="margin-top: 40px; color: #777; font-size: 12px; text-align: center;">
            Generated by SearchAI
        </div>
    </body>
    </html>
    """
    
    # Create a temporary HTML file
    loop = asyncio.get_event_loop()
    with tempfile.NamedTemporaryFile(suffix='.html', delete=False) as tmp_html:
        await loop.run_in_executor(None, lambda: tmp_html.write(styled_html.encode('utf-8')))
        html_path = tmp_html.name
    
    try:
        # Convert HTML to PDF using pdfkit
        pdf_options = {
            'page-size': 'Letter',
            'margin-top': '20mm',
            'margin-right': '20mm',
            'margin-bottom': '20mm',
            'margin-left': '20mm',
            'encoding': 'UTF-8',
            'no-outline': None,
            'title': query
        }
        
        # Run pdfkit conversion in a separate thread
        await loop.run_in_executor(
            None,
            lambda: pdfkit.from_file(html_path, output_path, options=pdf_options)
        )
        
        # Get file size
        file_size = os.path.getsize(output_path)
        logger.info(f"PDF document generated via markdown/pdfkit: {output_path}")
        
        return output_path, file_size
    finally:
        # Clean up the temporary HTML file
        if os.path.exists(html_path):
            os.remove(html_path)

async def _generate_pdf_via_reportlab(content: str, query: str, output_path: str) -> tuple:
    """
    Generate a PDF directly using ReportLab.
    """
    loop = asyncio.get_event_loop()
    
    def create_pdf():
        # Initialize the PDF document
        doc = SimpleDocTemplate(
            output_path,
            pagesize=letter,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=72
        )
        
        # Get styles
        styles = getSampleStyleSheet()
        
        # Custom styles
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Title'],
            fontSize=24,
            spaceAfter=30
        )
        
        heading_style = ParagraphStyle(
            'CustomHeading',
            parent=styles['Heading1'],
            fontSize=16,
            spaceAfter=12,
            spaceBefore=24
        )
        
        normal_style = ParagraphStyle(
            'CustomNormal',
            parent=styles['Normal'],
            fontSize=12,
            spaceAfter=12
        )
        
        bullet_style = ParagraphStyle(
            'CustomBullet',
            parent=styles['Normal'],
            fontSize=12,
            leftIndent=20,
            spaceAfter=12
        )
        
        reference_style = ParagraphStyle(
            'CustomReference',
            parent=styles['Normal'],
            fontSize=10,
            textColor=colors.HexColor('#666666')
        )
        
        # Start building the document
        story = []
        
        # Add title and timestamp
        story.append(Paragraph(query, title_style))
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        story.append(Paragraph(f"Generated on {timestamp}", normal_style))
        story.append(Spacer(1, 24))
        
        # Process content sections
        lines = content.split('\n')
        in_references = False
        current_text = []
        
        for line in lines:
            line = line.strip()
            
            if not line:
                if current_text:
                    story.append(Paragraph('\n'.join(current_text), normal_style))
                    current_text = []
                continue
                
            # Check for references section
            if line.lower() == 'references':
                if current_text:
                    story.append(Paragraph('\n'.join(current_text), normal_style))
                    current_text = []
                story.append(Spacer(1, 12))
                story.append(Paragraph(line, heading_style))
                in_references = True
                continue
            
            # Handle references
            if in_references:
                if line.startswith('['):
                    story.append(Paragraph(line, reference_style))
                continue
            
            # Handle headings (lines that don't start with bullet or number)
            if not line.startswith('•') and not line[0].isdigit() and len(line) < 50:
                if current_text:
                    story.append(Paragraph('\n'.join(current_text), normal_style))
                    current_text = []
                story.append(Spacer(1, 12))
                story.append(Paragraph(line, heading_style))
                continue
            
            # Handle bullet points
            if line.startswith('•'):
                if current_text:
                    story.append(Paragraph('\n'.join(current_text), normal_style))
                    current_text = []
                story.append(Paragraph(line, bullet_style))
                continue
            
            # Handle numbered points
            if line[0].isdigit() and line[1] == '.':
                if current_text:
                    story.append(Paragraph('\n'.join(current_text), normal_style))
                    current_text = []
                story.append(Paragraph(line, bullet_style))
                continue
            
            current_text.append(line)
        
        # Add any remaining text
        if current_text:
            story.append(Paragraph('\n'.join(current_text), normal_style))
        
        # Add footer
        story.append(Spacer(1, 36))
        footer_style = ParagraphStyle(
            'Footer',
            parent=styles['Normal'],
            fontSize=8,
            textColor=colors.HexColor('#999999'),
            alignment=1  # Center alignment
        )
        story.append(Paragraph("Generated by SearchAI", footer_style))
        
        # Build the PDF
        doc.build(story)
    
    # Run the PDF creation in a separate thread
    await loop.run_in_executor(None, create_pdf)
    
    # Get file size
    file_size = os.path.getsize(output_path)
    logger.info(f"PDF document generated via ReportLab: {output_path}")
    
    return output_path, file_size